/**
 * PDF Generator
 * Generates PDFs from enriched plans
 */

import { jsPDF } from 'jspdf';

export interface PDFData {
  problem: {
    summary: string;
    domain_of_life?: string;
    severity?: number;
  };
  actions: Array<{
    event_name?: string;
    name?: string;
    title?: string;
    description?: string;
    start_date?: string;
    duration_days?: number;
    metric?: string;
  }>;
  intent?: string;
  score?: number;
  userProfile?: {
    first_name?: string;
    city?: string;
    country?: string;
  };
  timestamp: string;
}

export interface PDFValidation {
  valid: boolean;
  warnings: string[];
}

/**
 * Generate PDF from enriched plan data
 */
export function generateEnrichedPlanPDF(data: PDFData): ArrayBuffer {
  const { problem, actions, intent, score, userProfile, timestamp } = data;
  
  // Create PDF
  const pdf = new jsPDF();
  const pageWidth = pdf.internal.pageSize.getWidth();
  const pageHeight = pdf.internal.pageSize.getHeight();
  let yPosition = 20;
  const lineHeight = 7;
  const margin = 20;
  const maxWidth = pageWidth - (margin * 2);

  // Helper function to add text with word wrap
  const addText = (text: string, fontSize: number = 12, isBold: boolean = false) => {
    pdf.setFontSize(fontSize);
    pdf.setFont('helvetica', isBold ? 'bold' : 'normal');
    
    const lines = pdf.splitTextToSize(String(text), maxWidth);
    
    if (yPosition + (lines.length * lineHeight) > pageHeight - 30) {
      pdf.addPage();
      yPosition = 20;
    }
    
    pdf.text(lines, margin, yPosition);
    yPosition += lines.length * lineHeight + 5;
  };

  // Title page
  pdf.setFontSize(24);
  pdf.setFont('helvetica', 'bold');
  pdf.text('DrishiQ Action Plan', margin, yPosition);
  yPosition += 15;

  pdf.setFontSize(12);
  pdf.setFont('helvetica', 'normal');
  addText(`Generated: ${new Date(timestamp).toLocaleString()}`, 10);
  
  if (userProfile?.first_name) {
    addText(`For: ${userProfile.first_name}`, 10);
  }

  yPosition += 10;

  // Problem Summary Section
  pdf.addPage();
  yPosition = 20;
  addText('Problem Summary', 18, true);
  yPosition += 5;

  if (problem.summary) {
    addText(problem.summary, 12);
    yPosition += 5;
  }

  if (problem.domain_of_life) {
    addText(`Domain: ${problem.domain_of_life}`, 10);
  }

  if (problem.severity !== undefined) {
    addText(`Severity: ${problem.severity}/10`, 10);
  }

  if (intent) {
    yPosition += 5;
    addText(`Intent: ${intent}`, 10);
  }

  // Actions Section
  if (actions && actions.length > 0) {
    pdf.addPage();
    yPosition = 20;
    addText('Recommended Actions', 18, true);
    yPosition += 5;

    actions.forEach((action, index) => {
      const actionName = action.event_name || action.name || action.title || `Action ${index + 1}`;
      addText(`${index + 1}. ${actionName}`, 14, true);
      
      if (action.description) {
        addText(`   ${action.description}`, 11);
      }
      
      if (action.start_date) {
        addText(`   Start: ${action.start_date}`, 10);
      }
      
      if (action.duration_days) {
        addText(`   Duration: ${action.duration_days} days`, 10);
      }
      
      if (action.metric) {
        addText(`   Metric: ${action.metric}`, 10);
      }
      
      yPosition += 3;
    });
  }

  // Score Section
  if (score !== undefined) {
    pdf.addPage();
    yPosition = 20;
    addText('Plan Confidence', 18, true);
    yPosition += 5;
    addText(`Confidence Score: ${Math.round(score)}%`, 14);
  }

  // Footer on all pages
  const totalPages = pdf.getNumberOfPages();
  for (let i = 1; i <= totalPages; i++) {
    pdf.setPage(i);
    pdf.setFontSize(8);
    pdf.setFont('helvetica', 'normal');
    pdf.text(
      `Page ${i} of ${totalPages} - Generated by DrishiQ`,
      margin,
      pageHeight - 10
    );
  }

  // Generate PDF buffer
  return Buffer.from(pdf.output('arraybuffer'));
}

/**
 * Validate PDF contents for PII leakage
 */
export function validatePDFContents(
  pdfBuffer: ArrayBuffer,
  allowedFields: string[] = []
): PDFValidation {
  const warnings: string[] = [];
  
  try {
    // Convert buffer to string for basic validation
    const bufferString = Buffer.from(pdfBuffer).toString('utf-8');
    
    // Check for common PII patterns
    const emailPattern = /\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b/g;
    const phonePattern = /\b\d{3}[-.]?\d{3}[-.]?\d{4}\b/g;
    const ssnPattern = /\b\d{3}-\d{2}-\d{4}\b/g;
    
    // Check for emails
    const emails = bufferString.match(emailPattern);
    if (emails && emails.length > 0 && !allowedFields.includes('email')) {
      warnings.push(`Found ${emails.length} email address(es) in PDF`);
    }
    
    // Check for phone numbers
    const phones = bufferString.match(phonePattern);
    if (phones && phones.length > 0 && !allowedFields.includes('phone')) {
      warnings.push(`Found ${phones.length} phone number(s) in PDF`);
    }
    
    // Check for SSN
    const ssns = bufferString.match(ssnPattern);
    if (ssns && ssns.length > 0) {
      warnings.push(`Found ${ssns.length} SSN(s) in PDF - CRITICAL`);
    }
    
    // Note: This is a basic check. For production, use a proper PDF parser
    // to extract text content more accurately
    
    return {
      valid: warnings.length === 0,
      warnings
    };
  } catch (error) {
    console.error('PDF validation error:', error);
    return {
      valid: false,
      warnings: ['Failed to validate PDF contents']
    };
  }
}




